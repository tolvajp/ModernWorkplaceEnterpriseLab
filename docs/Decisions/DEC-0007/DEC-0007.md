# Decision Log – Module refactoring principles

## Decision ID
- **ID:** DEC-0007
- **Status:** Draft
- **Date:** 2025-01-02
- **Owner:** Peter Tolvaj

---

## Context

The Modern Workplace Enterprise (MWE) PowerShell module has reached a stage where
organic growth and monolithic scripts no longer reflect how enterprise-grade
automation is designed, reasoned about, and maintained.

The module is not intended to be feature-complete.
Its purpose is to demonstrate **intentional design**, **operational discipline**,
and **clear architectural boundaries**, rather than maximal functional coverage.

This decision defines the **principles** that govern how the MWE module is
structured, evolved, refactored, and versioned going forward.

---

## Decisions

### DEC-0007-01 — Functional scope and definition of “done”

**Decision**  
The module includes only selected functional areas.  
There is no draft, experimental, or partial functionality.

If a function exists in the module, it is considered *complete*.

**Definition of Done**  
A function is considered complete when all of the following are true:

- Comment-based help is present (Synopsis and at least one example)
- Input validation is explicit and fail-fast
- Behavior is deterministic for a given input and tenant state
- Errors are terminating and not silently ignored
- Output is pipeline-compatible and object-based
- Supports `-WhatIf` / `ShouldProcess` semantics where the operation results in
  state changes

**Rationale**
This enforces a clear quality bar and prevents incomplete or experimental functionality from entering the module’s public surface.

---

### DEC-0007-02 — Public domain and internal separation

**Decision**  
Public functions represent **operational domains** of the module.

Internal implementation details are encapsulated in non-exported helper
functions and may evolve freely.

**Rationale**  
This establishes a stable, intentional public surface while allowing internal
refactoring without destabilizing usage or documentation.
For example, group creation is treated as a single public operational domain, so handled as a single public function, while internal implementation remain in the private realm. 

---

### DEC-0007-03 — Refactoring freedom and contract stability

**Decision**  
Internal refactoring is explicitly allowed and expected as the module evolves.

Public function contracts are treated as stable and intentional.
Any breaking change to a public contract must be reflected through versioning.

**Rationale**  
Refactoring is a normal part of understanding and improving a system.
Stability applies to the public contract, not the internal implementation.

---

### DEC-0007-04 — Module input model

**Decision**  
The module does not read configuration files or parse external data formats.

All required input is provided via parameters or structured objects supplied by
the caller.

**Rationale**  
This keeps the module focused on execution logic and avoids hidden side effects
or implicit dependencies on file system or execution context.

---

### DEC-0007-05 — Output and logging behavior

**Decision**  
`Write-Host` is prohibited in all module code.

Approved output mechanisms are:
- Structured object output
- `Write-Verbose`
- `Write-Information`
- `Write-Warning`
- `Write-Error`

**Rationale**  
This preserves pipeline compatibility, predictable behavior, scheduled run log shipping and composability
without introducing additional logging abstractions.

---

### DEC-0007-06 — Error handling and idempotency model

**Decision**
The module follows a fail-fast error handling model.
All errors are terminating.

Function behaviour is defined by a strict contract, of which the PowerShell verb is a mandatory part.
Functions are divided into two categories:

Imperative (lifecycle) functions use `New-` and `Remove-` verbs.
If a `New-*` function is executed and the target resource already exists, the function terminates with an error.
If a `Remove-*` function is executed and the target resource does not exist, the function terminates with an error.
Re-running lifecycle functions is considered a logical pipeline error.

Desired-state (convergent) functions use `Set-`, `Ensure-`, `Enable-`, `Disable-`, and `Assign-` verbs.
These functions enforce a declared desired state.
If the desired state is already met, the function performs no changes and returns success.
If the desired state is not met, the function converges the state where possible.
If convergence is not possible or validation fails, the function terminates with an error.

Verb naming is normative in this module: the verb defines the behavioural contract and expected idempotent behaviour.

Any introduction of a new verb must be documented and maintained in the Coding Conventions.

**Rationale**
The lab models enterprise-grade automation where intent must be explicit and behaviour must be predictable.
Fail-fast lifecycle functions prevent silent pipeline logic errors.
Desired-state functions enable safe re-execution, retryability, and configuration drift correction.
Making verb usage part of the contract ensures consistency, reviewability, and long-term maintainability.



---

### DEC-0007-07 — Authentication and authorization boundaries

**Decision**  
The module does not establish authentication contexts.

All public functions assume that authentication and authorization have already
been performed by the caller.
Required permissions and scopes are treated as preconditions.

If required permissions are missing, functions terminate immediately.

**Rationale**  
Authentication is an operational concern and must not be hidden inside module
logic. Explicit preconditions prevent unclear execution state and hidden side effects.

---

### DEC-0007-08 — Secrets and passwords are prohibited

**Decision**  
Secrets and passwords are not permitted anywhere in the module.

- No hard-coded secrets.
- No embedded credentials.
- No password material in code, configuration, examples, comments, or test data.
- If a secret is required operationally, it MUST be supplied externally by the caller via an approved secure mechanism.


**Rationale**

Storing secrets or passwords in source code is a high severity security risk.

---

### DEC-0007-09 — Automated validation

**Decision**  
The entire module MUST be covered by automated Pester tests.

- All public functions MUST have test coverage.
- Tests MUST be runnable in CI and locally.
- New or changed functionality MUST include corresponding test updates.


**Rationale**

- It protects contract stability: exported functions must keep behaving as documented; tests lock in that behavior and prevent accidental breaking changes.
- It enables safe refactoring: DEC-0007 explicitly allows internal refactoring; broad test coverage is what makes that freedom low-risk.
- It catches regressions early in CI/CD: changes that break anything fail fast, before merge/release.
- It forces deterministic, idempotent behavior to stay true: tests can assert “same input + same tenant state => same outcome,” including “already exists” paths.
- It improves maintainability and onboarding: tests are executable documentation for expected behavior and edge cases.

---

### DEC-0007-10 — Naming conventions

**Decision**  
All public functions and parameters follow strict naming conventions:

- Functions use approved PowerShell verbs and **Verb-Noun** naming.
- Function names and parameter names use **PascalCase**.
- Local variables use **camelCase**.

---

### DEC-0007-11 — Error handling defaults and call discipline

**Decision**  
The module enforces terminating errors by default.

- The module sets `$ErrorActionPreference = 'Stop'` at module import scope.
- Where a command may emit non-terminating errors, calls MUST explicitly use `-ErrorAction Stop`.
- Errors MUST NOT be silently ignored, downgraded, or suppressed.

**Rationale**  
Enforcing terminating errors at module level guarantees deterministic behavior in automation and prevents silent failure propagation.  
This setting affects the entire PowerShell session where the module is imported — and this is intentional for colleagues using this module.

**Positive:**  
- Fail-fast behavior is enforced consistently across the entire PowerShell session.  
- Errors surface immediately, close to their source, instead of becoming delayed surprises in later pipeline stages.

**Negative:**  
- Fail-fast behavior is enforced consistently across the entire PowerShell session.  
- Yes, this means you will notice errors sooner rather than later.

---

### DEC-0007-12 — Least privilege permission preconditions

**Decision**  
All functions require only the minimum necessary Graph/API permissions.

- Required permissions/scopes are treated as explicit preconditions of each function.
- Functions MUST NOT request broader scopes than necessary to perform their operation.

**Rationale**
Treating permissions as explicit preconditions keeps security boundaries visible and avoids hidden privilege escalation inside module logic.

---

### DEC-0007-13 — Module versioning policy

**Decision**
The module follows a strict versioning policy.

Major version increments when a public function surface is broken.
This includes changes where an existing parameter set, parameter behavior, or invocation pattern no longer works as previously defined.

Minor version increments when new public functionality is introduced.
This includes adding new public functions or extending existing functions with new, backward-compatible capabilities.

Patch version increments when no new public functions or functionality are introduced.
Patch releases are limited to internal refactoring, bug fixes, documentation updates, or test changes that do not alter public behavior.